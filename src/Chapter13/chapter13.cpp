// 1. 继承公有跟保护的成员变量及其公有的方法,私有成员被继承，但不能被访问

// 2. 不能继承构造函数，析构函数，赋值操作符跟友元函数

// ３．如果返回类型是void,可以使用单个赋值，不能使用连锁赋值
// 　　返回对象的话，该方法执行的速度将有所下降，因为需要复制对象

// ４．先调用基类的构造函数，再调用派生类的构造函数
//     先调用派生类的析构函数，再调用基类的析构函数

// 5. 需要

// 6. 看他们的参数，如果参数一样，调用派生类的方法

// 7. 有动态分配内存的时候，需要深复刻的时候，
//     对派生类来说，默认赋值不正确，应定义赋值操作符


// 8. 可以,  只有通过显式类型转换才行。

// 9. 不可以, 可以

// 10. 可以，C++允许基类指向从该基类派生的任何类型

// 11. 因为它会默认调用向下转换

// 12. 因为按引用传递比按值传递少了创建临时变量，调用构造函数，析构函数，赋值等操作。

// 13. a.  ph->head() 将调用Corporation基类的方法
//     b.  ph->head() 将调用PublicCorporation派生类的方法

// 14. 派生类只能通过基类的公有方法访问基类的私有成员变量